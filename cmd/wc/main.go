package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"unicode"

	mr_commands "github.com/ruggeri/nedreduce/pkg/commands"
	mr_types "github.com/ruggeri/nedreduce/pkg/types"
)

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
func wordSplittingMappingFunction(
	filename string,
	line string,
	emitterFunction mr_types.EmitterFunction,
) {
	words := strings.FieldsFunc(line, func(r rune) bool {
		return !unicode.IsLetter(r)
	})

	for _, word := range words {
		outputKeyValue := mr_types.KeyValue{word, ""}
		emitterFunction(outputKeyValue)
	}
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
func wordCountingReducingFunction(
	groupKey string,
	groupIteratorFunction mr_types.GroupIteratorFunction,
	emitterFunction mr_types.EmitterFunction,
) {
	wordCount := 0

	for {
		_, err := groupIteratorFunction()

		if err == io.EOF {
			break
		} else if err != nil {
			log.Fatalf("Unexpected error from group iterator")
		}

		wordCount++
	}

	keyValue := mr_types.KeyValue{
		Key:   groupKey,
		Value: strconv.Itoa(wordCount),
	}

	emitterFunction(keyValue)
}

// Can be run in 3 ways:
// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)
// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)
// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &)
func main() {
	if len(os.Args) < 4 {
		fmt.Printf("%s: see usage comments in file\n", os.Args[0])
	} else if os.Args[1] == "master" {
		jobConfiguration := mr_types.NewJobConfiguration(
			"wcseq",
			os.Args[3:],
			3,
			wordSplittingMappingFunction,
			wordCountingReducingFunction,
		)

		if os.Args[2] == "sequential" {
			mr_commands.RunSequentialJob(&jobConfiguration)
		} else {
			mr_commands.RunDistributedJob(&jobConfiguration, os.Args[2])
		}
	} else {
		mr_commands.RunWorker(
			os.Args[2],
			os.Args[3],
			wordSplittingMappingFunction,
			wordCountingReducingFunction,
			100,
		)
	}
}
